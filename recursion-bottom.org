#+title: Recursion: where FP hits âŠ¥
#+author: Greg Pfeil
#+date: Friday, 27 May 2016
#+email: greg@technomadic.org
#+options: d:(not LOGBOOK SPEAKERNOTES)
#+drawers: SPEAKERNOTES
#+epresent_frame_level: 4
#+epresent_face_attributes: (:family "Adobe Caslon Pro" :height 400)
#+epresent_mode_line: (" @sellout" "                          " "Recursion: where FP hits âŠ¥"     "                                       " (:eval (int-to-string epresent-page-number)))










  â†“ Twitter                                                                                   slide number â†“

* *âŠ¥* â€“ a.k.a. â€œbottomâ€

  :speakernotes:
Bottom in programming languages is the type of a computation that doesnâ€™t complete successfully. FP has managed to reign in a lot of the things that trigger it:
  :END:

- exceptions
- exhaustivity ([[http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm-acm.pdf][ /GADTs Meet Their Match/ ]])
- recursion
- deadlocks
- â€¦

:speakernotes:
Even very complicated pattern matching â€“ involving extensions like guards, GADTs, and view patterns, can now be  [needs citation]

but one aspect that still plagues most FP environments is non-termination. That is â€“ infinite recursion.

Some languages, called â€œtotalâ€ languages, also take care of this. Roughly, they make sure that every recursive call operates on a â€œsmallerâ€ value. How many of you get to spend a lot of time working in total languages? Coq? Agda? Idris? Yeah, thatâ€™s about what I expected.

So how can we get at least some of those benefits of controlled recursion in the languages we use today?
:END:

* background

  :speakernotes:
- whoâ€™s familiar with Haskell or Scala?
- some other statically-typed language?
- how about foldRight / reduce?
- unfold?
  :END:

- examples in Haskell and Scala

- *Haskell* â€“ Ed Kmettâ€™s library (https://github.com/ekmett/recursion-schemes)
- *Scala* â€“ SlamDataâ€™s Matryoshka (https://github.com/slamdata/matryoshka)

- [[https://github.com/sellout/recursion-scheme-talk]]

:speakernotes:
For the Clojure contingent, jneen may have said that Tulip is not quite a lisp, then showed some Tulip that was valid Haskell. Iâ€™m going to claim that Haskell is almost a Lisp â€“ especially if you write it the way I do. So, Clojurites, look at the Haskell examples.
:END:

* a recursive type

#+begin_src haskell -n
data Expr = Mul Expr Expr | Add Expr Expr | Num Int
#+end_src

#+begin_src scala
sealed trait Expr
final case class Mul(a: Expr, b: Expr) extends Expr
final case class Add(a: Expr, b: Expr) extends Expr
final case class Num(i: Int)           extends Expr
#+end_src

#+begin_src haskell -n
eval âˆ· Expr â†’ Int
eval (Mul a b) = eval a * eval b
eval (Add a b) = eval a + eval b
eval (Num n)   = n
#+end_src

:speakernotes:
Recursion appears in two places here â€“ we have a data type that refers to itself, and a function that calls itself.
:END:

* separation





                                         *operation   â‡†   recursion*









** the functor

   :speakernotes:
Letâ€™s start by removing the recursion from the data type.
   :END:

#+begin_src haskell -n
data Expr a = Mul a a | Add a a | Num Int
#+end_src

#+begin_src scala
sealed trait Expr[A]
final case class Mul[A](a: A, b: A) extends Expr[A]
final case class Add[A](a: A, b: A) extends Expr[A]
final case class Num[A](i: Int)     extends Expr[A]
#+end_src

   :speakernotes:
this makes it a functor, sometimes called a â€œpattern functorâ€. You can do this transformation to anyâ€  recursive structure â€“ XML, JSON, List, etc..

[â€ ]: Structural recursion is difficult. But also uncommon. It needs a variant of this approach that isnâ€™t supported by any tools Iâ€™m aware of â€¦ yet.
   :END:

** attempts

:speakernotes:
Now we have to figure out how to represent that recursive structure again.
:END:


#+begin_src haskell -n
data Expr a = â€¦
#+end_src

#+begin_src haskell -n
Expr Expr -- ğŸš«
#+end_src

   :speakernotes:
except that Expr is still a functor, and so it needs an argument
   :END:

#+begin_src haskell -n
Expr (Expr (Expr (Expr â€¦))) -- ğŸš«

Expr (Expr (Expr (Expr ()))) -- â“
#+end_src

** fixed-point types

#+begin_src haskell -n
data Fix f = Fix (f (Fix f))
project âˆ· Fix f â†’ f (Fix f)
project (Fix f) = f

Fix Expr
#+end_src

#+begin_src scala
case class Fix[F[_]](project: F[Fix[F]])

Fix[Expr]
#+end_src

** what about ~eval~?

#+begin_src haskell -n
eval âˆ· Fix Expr â†’ Int
eval (Fix (Mul a b)) = eval a * eval b
eval (Fix (Add a b)) = eval a + eval b
eval (Fix (Num n))   = n
#+end_src

   :speakernotes:
It just got uglier!

Just as we separated Fix from our data structure, we can separate the recursion from our ~eval~ function.
   :END:









*** an algebra

#+begin_src haskell -n
eval âˆ· Fix Expr â†’ Int
eval (Fix (Mul a b)) = eval a * eval b
eval (Fix (Add a b)) = eval a + eval b
eval (Fix (Num n))   = n
#+end_src

#+begin_src haskell -n
eval âˆ· Expr Int â†’ Int
eval (Mul a b) = a * b
eval (Add a b) = a + b
eval (Num n)   = n
#+end_src

*** So, whatâ€™s /an/ algebra?
or, â€œI know what algebra is, and these ainâ€™t it.â€

#+begin_src haskell -n
type Algebra f a = f a â†’ a

eval âˆ· Algebra Expr Int
#+end_src

:speakernotes:
The algebras (and coalgebras, etc.) are more properly known as â€œF-algebrasâ€. To connect these back to the algebra weâ€™re all generally familiar with from school, letâ€™s look at a simple ADT â€“

We can write out a simple expression
:END:









**** an expression

#+begin_src haskell -n
val expr = Fix (Add (Fix (Mul (Fix (Add (Fix (Num 2)) (Fix â€¦
                              (Fix (Num 4))))
                    (Fix (Add (Fix (Mul (Fix (Num 5)) (Fix â€¦
                              (Fix (Num 7)))))
#+end_src

#+begin_src scala
val expr =
  Fix(Add(Fix(Mul(Fix(Add(Fix(Num[Mu[Expr]](2)), Fix(Num[Muâ€¦
                  Fix(Num[Mu[Expr]](4)))),
          Fix(Add(Fix(Mul(Fix(Num[Mu[Expr]](5)), Fix(Num[Muâ€¦
                  Fix(Num[Mu[Expr]](7))))))
#+end_src

**** cleaner (a.k.a, lying)

#+begin_src haskell -n
val expr = Add (Mul (Add (Num 2) (Num 3))
                    (Num 4))
               (Add (Mul (Num 5) (Num 6))
                    (Num 7))
#+end_src

#+begin_src scala
val expr =
  Add(Mul(Add(Num(2), Num(3)),
          Num(4)),
      Add(Mul(Num(5), Num(6)),
          Num(7)))
#+end_src

*((2 + 3) Ã— 4) + ((5 Ã— 6) + 7)*

:speakernotes:
which would have looked like *(2 + 3) Ã— 4 + 5 Ã— 6 + 7* back in high school. To make the precedence a bit more explicit, here are some extra parens: *((2 + 3) Ã— 4) + ((5 Ã— 6) + 7)*.
:END:

**** arithmetic

:speakernotes:
Now, how do we solve / evaluate this? If youâ€™re anything like me, you take a few steps:
:END:
1. *((2 + 3) Ã— 4) + ((5 Ã— 6) + 7)*
2. *( â€‡ 5 â€‡   Ã— 4) + ( â€‡30â€‡  + 7)*
3.         *20â€‡ â€‡  +   â€‡â€‡37*
4.                  *57*
:speakernotes:
So, there are two aspects to this. First, there are some simple rules:
:END:
#+begin_src scala
val eval: Algebra[Expr, Int] = { // Expr[Int] â‡’ Int
  // 1. + means to add two numbers together
  case Add(x, y)  â‡’ x + y
  // 2. * means to multiply to numbers together
  case Mult(x, y) â‡’ x * y
  // 3. a number simply represents itself
  case Num(x)     â‡’ x
}
#+end_src

Hey, look at that â€“ this evaluation rule is an â€œalgebraâ€. And itâ€™s just a simplified version of the particular algebra we grew up with.

*** and a fold

    :speakernotes:
And what is the recursion-adding analogue of ~Fix~ here?
    :END:

#+begin_src haskell -n
cata âˆ· Functor f â‡’ (f a â†’ a) â†’ Fix f â†’ a
cata Ï† (Fix f) = Ï† (fmap (cata Ï†) f)
#+end_src

#+begin_src haskell -n
cata eval âˆ· Fix Expr â†’ Int
#+end_src

    :speakernotes:
You may already be familiar with this concept:
    :END:

*** look familiar?

#+begin_src haskell -n
myList = [1, 2, 3, 4]
foldr (+) 0 myList -- 10
#+end_src

#+begin_src scala
val myList = List(1, 2, 3, 4)
myList.foldRight(0)(_ + _) // 10
#+end_src

#+begin_src haskell -n
data ListF a b = Nil | Cons a b
type List a = Fix (ListF a)

foldr âˆ· (a â†’ b â†’ b) â†’ b â†’ List a â†’ b
foldr f z = cata (\case
                    Cons a b â†’ f a b
                    Nil      â†’ z)
#+end_src

* dueling duals

  :speakernotes:
Something that comes up a lot in the FP world is duals, you flip some arrows, and you come up with something that is the â€œoppositeâ€ of what you had before.
  :END:

** coalgebras

#+begin_src haskell -n
type Algebra   f a = f a â†’   a
type Coalgebra f a =   a â†’ f a

factors âˆ· Coalgebra Expr Int
factors n = if n > 2 && n % 2 == 0
              then Mul 2 (n / 2)
              else Num n
#+end_src

*48*
*2 * 24*
*2 Ã— (2 Ã— 12)*
*2 Ã— (2 Ã— (2 Ã— 6))*
*2 Ã— (2 Ã— (2 Ã— (2 Ã— 3)))*

** unfolds

#+begin_src haskell -n
ana âˆ· Functor f â‡’ (a â†’ f a) â†’ a â†’ Fix f
ana  Ïˆ a = Fix (fmap (ana Ïˆ) (Ïˆ a))
cata Ï† (Fix f) = Ï† (fmap (cata Ï†) f)
#+end_src

#+begin_src haskell -n
ana factors âˆ· Int â†’ Fix Expr
#+end_src

:speakernotes:
An example here is parsers. When you â€œrunâ€ the parser monad, you can actually get a Cofree structure, annotated with the source position.
:END:


** corecursion

*** the problem with ~Fix~

:speakernotes:
The ~Fix~ type weâ€™ve been using is nice and simple, but itâ€™s a bit â€¦ unprincipled. For one, itâ€™s still recursive. We have at least constrained recursion to this one library, but itâ€™s still there. Weâ€™ll see later another place where it can cause a problem. But in the mean time, letâ€™s replace it with something better.
:END:

#+begin_src haskell -n
data Fix f = Fix (f (Fix f)) -- ğŸš«
#+end_src

#+begin_src haskell -n
data Mu f = forall a. (f a â†’ a) â†’ a

cata (Mu Ï†) = Ï†
#+end_src

:speakernotes:
If you look at the definition of ~Mu~, its parameter is a function that takes an algebra, and returns the result of applying it. This eliminates the recursion from the definition, and from the corresponding definition of cata. So, weâ€™ve now truly eliminated unbounded recursion here. This is the recursive fixed point.
:END:

*** ok, really corecursion

:speakernotes:
So, weâ€™ve been talking about eliminating infinite loops, but there are cases where you /want/ infinite loops, right? Like event
:END:

#+begin_src haskell -n
data Nu f where Nu âˆ· (a â†’ f a) â†’ a â†’ Nu f

ana = Nu
project (Nu f a) = fmap (Nu f) (f a)
#+end_src

* What is all this for again?!

:speakernotes:
Ostensibly, this was about eliminating recursion. And we did that. But we get a lot more out of this, and these are the reasons why I really think this is an approach that should be used directly.
:END:

** deferred decision-making

:speakernotes:
Even with a language like Idris, you have to decide between data and codata up front â€“ and implement two sets of type classes.
:END:

#+begin_src idris
data   List a   = Nil | Cons a (List a)
codata Stream a = Nil | Cons a (Stream a)
#+end_src

#+begin_src haskell -n
data ListF a b = Nil | Cons a b

type List a   = Mu (ListF a)
type Stream a = Nu (ListF a)
#+end_src

** general

   :speakernotes:
There are plenty of algebras that can be defined for large sets of data structures.
   :END:

#+begin_src scala
def count(form: Mu[F]): GAlgebra[(Mu[F], ?), F, Int] =
  e â‡’ e.foldRight(
    if (e âˆ˜ (_._1) == form.project) 1 else 0)(
    _._2 + _)

def size: F[Int] â‡’ Int = _.foldRight(1)(_ + _)

def height: F[Int] â‡’ Int = _.foldRight(0)(_ max _)
#+end_src


** compositional

*** coproducts





*This slide has been postponed to 16:00. (Patrick Thomson)*

*** annotations

#+begin_src haskell -n
Fix Expr
#+end_src

Mul
â”œâ”€ Num 6
â””â”€ Num 7

#+begin_src haskell -n
Cofree Expr Int
#+end_src

Mul (0)
â”œâ”€ Num 6 (1)
â””â”€ Num 7 (1)

*** algebra transformations

#+begin_src haskell -n
attribute âˆ· Algebra f a â†’ Algebra f (Cofree f a)

ignoreAttribute âˆ· Algebra (EnvT f b) a â†’ Algebra f a

generalize âˆ· Algebra f a â†’ GAlgebra w f a

type GAlgebra w f a = f (w a) â†’ a
type GCoalgbra m f a = f a â†’ m a
#+end_src


** efficient

    :speakernotes:
With this layer-at-a-time approach, we can now also do additional work at each step.
    :END:

*** hylomorphisms
     :speakernotes:
- when you traverse a recursive data structure, you start at the root, move toward the leaves, then then back to the root.
- an algebra gets applied to your structure on the way back to the root
- but a coalgebra gets applied on the way to the leaves
- so, if you have a coalgebra followed by an algebra (~cata Ï† â‹˜ ana Ïˆ~), you can apply both transformations in a single pass, as ~hylo Ï† Ïˆ~
     :END:
#+begin_src php
     â†˜                     â†—
       â†˜                 â†—
         â†˜     hylo    â†—
           â†˜         â†—
         ana â†˜     â†— cata
               â†˜_â†—
 #+end_src

#+begin_src haskell -n
cata bottomUp â‹˜ ana topDown

hylo bottomUp topDown
#+end_src

#+begin_src scala
_.ana(topDown).cata(bottomUp)

_.hylo(bottomUp, topDown)
#+end_src

*** zygomorphisms

 :speakernotes:
We talked earlier about how to use Cofree to annotate your tree with arbitrary information.
:END:

#+begin_src haskell -n
buInferType âˆ· Lambda Type â†’ Type

cata (attribute buInferType) âˆ· Fix Lambda â†’ Cofree Lambda Type

useType1 âˆ· Lambda (Type, Value) â†’ Value
zygo inferType useType1 âˆ· Fix Lambda â†’ Value

tdInferType âˆ· (Type, Fix Lambda) â†’ Lambda (Type, Fix Lambda)
useType2 âˆ· (Type, Lambda Value) â†’ Value
coelgot useType2 tdInferType âˆ· Fix Lambda â†’ Value
#+end_src

*** Elgot algebras

#+begin_src scala
val buInferType: Lambda[Type] â‡’ Type

lam.cata(buInferType.attribute): Cofree[Lambda, Type]

val useType1: Lambda[(Type, Value)] â‡’ Value
lam.zygo(inferType, useType1): Value

val tdInferType: (Type, Fix[Lambda]) â‡’ Lambda[(Type, Fix[Lambda])]
val useType2: (Type, Lambda[Value]) â‡’ Value
lam.coelgot(useType2, tdInferType): Value
#+end_src

*** zip

#+begin_src haskell -n
pprint âˆ· Expr String â†’ String
eval âˆ· Expr Int â†’ Int

cata (zip pprint eval) âˆ· Mu Expr â†’ (String, Int)
#+end_src

#+begin_src scala
val pprint: Expr[String] â‡’ String
val eval: Expr[Int] â‡’ Int

_.cata(pprint zip eval): Mu[Expr] â‡’ (String, Int)
#+end_src

* a real-world example
#+begin_src haskell -n
projectSortKeys âˆ· Sql (Mu Sql) â‡’ Maybe (Sql (Mu Sql))
scopeTables âˆ· CoalgebraM (Either Error) Sql (Scope, Mu Sql)
identifySynthetics âˆ· Algebra Sql [Maybe Synthetic]
inferProv âˆ· ElgotAlgebraM ((,) Scope) (Either Error) Sql Prov

-- projectSort â‹™ (identSynth &&& (scopeTables â‹™ inferProv))
allPhases âˆ· Mu Sql â†’ Cofree Sql ([Maybe Synthetic], Prov)
allPhases expr =
  coelgotM (attributeAlgebra
            (zip (return â‹˜ (generalizeE identifySynthetics))
                 inferProv))
           scopeTables
           (transCata (orOriginal projectSortKeys) ([], expr))
#+end_src

* the Fix programming language

:speakernotes:
Programming languages are my job and my hobby. So, when I work with a problem like this, I wonder about what would a programming language based on this look like?
:END:
- total
- no recursion â€“ all references form a DAG
- discoverable minimum complete definitions of type classes (NP hard â€¦ but thatâ€™s a different talk)
- strongly normalizing
- function equality â‰

* questions?

- *Haskell* â€“ Ed Kmettâ€™s library  (https://github.com/ekmett/recursion-schemes)
- *Scala* â€“ SlamDataâ€™s Matryoshka (https://github.com/slamdata/matryoshka)

- [[https://github.com/sellout/recursion-scheme-talk]]
